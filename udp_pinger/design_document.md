# Описание алгоритма: UDP Pinger

## 1. Введение

Проект `UDP Pinger` состоит из двух приложений: клиента и сервера. Цель клиента — отправлять UDP-пакеты на сервер, измерять время возврата ответа (Round-Trip Time, RTT) и отслеживать потери, которые симулирует сервер. Это позволяет на практике изучить работу с ненадежным протоколом UDP и механизмами таймаутов.

## 2. Алгоритм работы клиента

Клиент выполняет следующую последовательность действий:

1.  **Инициализация**: Создается UDP-сокет. Важнейшим шагом является установка таймаута на операции чтения из сокета с помощью системного вызова `setsockopt` с опцией `SO_RCVTIMEO`. В данном проекте таймаут установлен на 1 секунду. Это означает, что вызов `recvfrom` будет ожидать ответа не более одной секунды.

2.  **Цикл отправки**: Клиент входит в цикл, который повторяется 10 раз для отправки 10 ping-сообщений.

3.  **Расчет RTT**:
    *   **Перед отправкой** пакета фиксируется время `start_time` с высоким разрешением (`std::chrono::high_resolution_clock`).
    *   Формируется сообщение вида `Ping <порядковый_номер> <timestamp_в_мс>`.
    *   Пакет отправляется на сервер с помощью `sendto`.
    *   Программа немедленно вызывает `recvfrom`, который блокирует выполнение.
    *   **Если ответ получен** (`recvfrom` возвращает положительное число), немедленно фиксируется время `end_time`. RTT вычисляется как разница: `RTT = end_time - start_time`. Результат выводится на экран.
    *   **Если ответ не получен в течение 1 секунды**, вызов `recvfrom` прерывается по таймауту и возвращает `-1`. Программа обрабатывает это как потерю пакета и выводит сообщение "Request timed out".

4.  **Сбор статистики**: В ходе работы клиент подсчитывает количество отправленных и полученных пакетов, а также сохраняет все успешные значения RTT в список.

5.  **Итоговый отчет**: После завершения цикла клиент вычисляет и выводит итоговую статистику:
    *   Общее количество отправленных, полученных и потерянных пакетов.
    *   Процент потерь.
    *   Минимальное, максимальное и среднее время RTT.

## 3. Алгоритм работы сервера

Сервер выполняет простую роль "эха" с имитацией потерь:

1.  **Инициализация**: Создается и привязывается к указанному порту UDP-сокет. Сервер входит в бесконечный цикл ожидания пакетов.
2.  **Симуляция потерь**: При получении каждого пакета генерируется случайное число. Если это число меньше заданного порога (`LOSS_RATE`, например, 0.3), сервер имитирует потерю, просто игнорируя пакет и не отправляя ответ.
3.  **Отправка эха**: Если пакет не "потерян", сервер немедленно отправляет полученные данные обратно тому же клиенту, от которого они пришли, используя адрес из вызова `recvfrom`.

## 4. Инструкция по сборке и запуску

### Сборка
Проект собирается с помощью `CMake` в CLion. `CMakeLists.txt` настроен на создание двух исполняемых файлов: `udp_pinger_server` и `udp_pinger_client`.

### Запуск
Для работы требуется два терминала.

1.  **Запустите сервер (в первом терминале):**
    *   Перейдите в директорию сборки (`cmake-build-debug`).
    *   Выполните команду, указав порт для прослушивания (например, 12000):
        ```bash
        ./udp_pinger_server 12000
        ```

2.  **Запустите клиент (во втором терминале):**
    *   Также перейдите в директорию `cmake-build-debug`.
    *   Выполните команду, указав хост (`localhost` или `127.0.0.1`) и порт сервера:
        ```bash
        ./udp_pinger_client 127.0.0.1 12000
        ```

### Пример вывода клиента
Ответ от сервера: Ping 1 1630578123, RTT = 0.001 сек
Request timed out
Ответ от сервера: Ping 3 1630578125, RTT = 0.000 сек
...
Ответ от сервера: Ping 10 1630578132, RTT = 0.001 сек
--- Статистика ping ---
Отправлено: 10, Получено: 7, Потеряно: 3 (30.0%)
RTT: мин = 0.000с, макс = 0.002с, средн = 0.001с
